 

If **\*print-array\*** is *true* and **\*print-readably\*** is *false*, any *array* other than a *vector* is printed using #nA format. Let n be the *rank* of the *array*. Then # is printed, then n as a decimal integer, then A, then n open parentheses. Next the *elements* are scanned in row-major order, using **write** on each *element*, and separating *elements* from each other with *whitespace*&#60;sub&#62;1&#60;/sub&#62;. The array’s dimensions are numbered 0 to n-1 from left to right, and are enumerated with the rightmost index changing fastest. Every time the index for dimension j is incremented, the following actions are taken: 

*•* If j &#60; n-1, then a close parenthesis is printed. 

*•* If incrementing the index for dimension j caused it to equal dimension j, that index is reset to zero and the index for dimension j-1 is incremented (thereby performing these three steps recursively), unless j=0, in which case the entire algorithm is terminated. If incrementing the index for dimension j did not cause it to equal dimension j, then a space is printed. 

*•* If j &#60; n-1, then an open parenthesis is printed. 

This causes the contents to be printed in a format suitable for :initial-contents to **make-array**. The lists effectively printed by this procedure are subject to truncation by **\*print-level\*** and **\*print-length\***. 

If the *array* is of a specialized *type*, containing bits or characters, then the innermost lists generated by the algorithm given above can instead be printed using bit-vector or string syntax, provided that these innermost lists would not be subject to truncation by **\*print-length\***. 

If both **\*print-array\*** and **\*print-readably\*** are *false*, then the *array* is printed in a format (using #&#60;) that is concise but not readable. 

If **\*print-readably\*** is *true*, the *array* prints in an *implementation-defined* manner; see the *variable* **\*print-readably\***. In particular, this may be important for arrays having some dimension 0. 

For information on how the *Lisp reader* parses these “other *arrays*,” see Section 2.4.8.12 (Sharpsign A). 

